---
layout: post
title: "【T】JVM内存数据区"
---

JVM的内存区域由其管理并根据职能划分为不同的数据区域，根据《Java虚拟机规范》的规定，内存区域划分为：

* 程序计数器
* 方法区
* 虚拟机栈
* 本地方法栈
* 堆

# 1 Java虚拟机内存区域

## 1.1 程序计数器
简单来说，「程序计数器」是线程维度的，用于标识线程当前执行的字节码位置的行号指示器。如果线程执行的是Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，那么为空。

多线程情景下的线程切换（切换到上次执行的位置），分支、循环、跳转、异常处理等等都依赖程序计数器。

## 1.2 虚拟机栈
Java虚拟机栈是线程维度的，用于存储线程执行过程中方法粒度的信息，这些信息存储在创建的栈帧中，包含局部变量表、操作栈、方法出口等信息。每一个方法执行的过程，就对应一个入栈到出栈的过程。

这个区域可能出现如下两种异常：
* StackOverFlow: 栈深度的问题。
* OutOfMemory：内存不足的问题。

## 1.3 本地方法栈
按照虚拟机规范来讲，本地方法栈和虚拟机栈的区别在于虚拟机栈负责Java方法的执行，本地方法栈负责Native方法的执行。HotSpot虚拟机无此区分，二者为一个区域。

## 1.4 Java堆
堆区域为线程共享，存放所有类实例的内存区域。堆是垃圾回收管理的主要区域，以此角度分，堆可以分为新生代和老年代。

## 1.5 方法区
方法区为线程共享的，用于存放类、常量、静态变量、编译后的代码等数据。低版本的HotSpot，使用「永久区」的方式实现方法区。

运行时常量池是方法区的一部分，用于存放编译期或动态生成的字符常量和符号引用。

除以上虚拟机运行内存区之外，直接内存（Direct Memory）也可以被JVM通过Native方法使用，这类内存不受JVM分配的内存大小的限制，但是同样会因为内存不足导致 OutOfMemroy。

# 2 一个例子
以 MyObj o = new MyObj()为例：
* 「MyObj o」会以 reference 类型出现在JVM内存区域中的「栈」本地变量表中。
* 「new MyObj()」在堆上进行内存分配。
* 在「方法区」中包含此对象的类型数据，如类型，父类，接口，方法等。



以上，为JVM虚拟机内存区域划分，以及每个内存区域的作用与相互之间的联系。


参考：
* 《深入理解Java虚拟机》
