<h2 id="section">读后感</h2>

<p>其中的一些方法平时自己也能悟得一二，但是有些规则的确读后醍醐灌顶，拍案叫绝。</p>

<h2 id="section-1">整理</h2>

<blockquote>
  <p>不是目录, 是目录 + 理解 :)</p>
</blockquote>

<h3 id="section-2">垃圾代码的表现</h3>

<p>1 毫无节制的方法，过多的参数，过大的类。  <br />
简单、清晰、内聚是最好的指导原则。</p>

<p>2 调用链与委托</p>

<p><code>
status = model.getBase().getStatus()
</code></p>

<p>调用端是否有必要知道base的存在是是否委托的判断条件。
委托的目的是隐藏更底层的逻辑关系，调用方没必要了解这些关系，也更符合封装的原则。</p>

<p>…</p>

<hr />
<p>方法、类与数据，所有的代码无疑是使用这三个工具完成需求。
主要的优化点与指导原则也在这三大块上。</p>

<h3 id="section-3">方法</h3>

<p>1 提炼函数与过度提炼。  <br />
2 [good]行为平行是关键。</p>

<p>```
// 像什么 放油、爆锅之类的放在cook中，而不应该与下面这几步骤平行
public prepareDinner(){
    buy();
    wash();
    cook();
}</p>

<p>```</p>

<p>3 以查询取代临时变量。  <br />
4 以函数对象取代函数。  <br />
在原对象大的无法处理时，进一步划分，按照职责拆解函数到对应的对象中。</p>

<p>5 [good]不能对参数赋值。    <br />
想要改变参数，又想提炼函数，怎么办？把这个方法放到想要改变参数的对象中。
Java的按值传递性。</p>

<p>6 引入NULL对象  <br />
这个很有意思，通过集成原对象，并对NULL对象的元素赋初始值，在父类和NULL子类上都实现isNull方法，这种的应用场景是大部分元素都可能为空的情况。</p>

<p>7 将查询函数和修改函数分离  <br />
无非是各自为政，也称为 <strong>单一职责</strong>。</p>

<p>8 以明确函数取代参数</p>

<p>9 以工厂函数取代构造函数</p>

<p>10 以异常取代错误码</p>

<h3 id="section-4">类</h3>

<p>1 父类与子类各司其职  <br />
父类中应该是更通用的动作，子类是更具体的动作。</p>

<p>其中涉及到的概念包括：  <br />
* 字段上移/下移  <br />
* 函数上移/下移
* 子类提炼</p>

<p>2 尽量做到 <strong>面向对象</strong></p>

<h2 id="section-5">数据</h2>

<p>使用 <strong>面向对象</strong> 的思想组织，能提炼为类的都变为类。</p>

<h3 id="section-6">测试为上</h3>

<p>最近写代码也很有感触，自测，单测才是避免bug的最为有效的办法，而十分钟的单测，其转化率往往是一个小时的 bug 寻找，有 bug 无所谓， 所谓的是 <strong>挫败感</strong> 和寻找过程中的 <strong>无力感</strong> 。</p>
