---
layout: post
title: "【T】JAVA并发编程（二）任务执行"
---

## 1 任务执行模式
使用「请求-线程池」模式而非「请求-线程」模式主要是为了优化过多线程在：
* 线程创建与关闭的资源消耗
* 空闲线程的资源占用以及CPU资源的竞争
等等。通常资源池化是解决诸如此类问题的最通用的方式之一。


#### 1.1 有效的并行

假设任务A执行时间为90ms，任务B为10ms，试想两种情况：
* 串行执行，耗时为100ms+。特点：代码简单编写并且易懂，维护轻量。
* 并行执行，理想是90ms+。特点：代码层面复杂，维护难。系统层面增加了CPU任务协调负担与资源竞争等。

其实，此种情况的并行收益并不明显。

原则：
> **大量** 相互独立且 **同类** 的任务进行 **并发** 处理，才能将任务进行有效的分配，进而获得性能的提升。

## 2 任务执行框架与工具

#### 2.1 ExecutorService vs CompletionService

同样作为异步执行的框架，二者在实现上的不同主要体现在：

> * ExecutorService = incoming queue + worker threads
> * CompletionService = incoming queue + worker threads + output queue

其中 CompletionService 更大的优点在于对isDone的Task的获取的便利性，而不需要按照既定的顺序去
同步等待结果，举个例子：

* 并行获取4个资源，当有3个返回时就视为成功，并获取结果，cancel掉未返回的结果。

如下是一个使用 `CompletionService` 的例子([StackOverFlow](https://stackoverflow.com/questions/4912228/when-should-i-use-a-completionservice-over-an-executorservice))：

```
ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
CompletionService<CalcResult> taskCompletionService =
        new ExecutorCompletionService<CalcResult>(taskExecutor);

int submittedTasks = 5;
for(int i=0;i< submittedTasks;i++){
    taskCompletionService.submit(new CallableTask(
            String.valueOf(i),
            (i * 10),
            ((i * 10) + 10  )
    ));
    System.out.println("Task " + String.valueOf(i) + "subitted");
}
for(int tasksHandled=0;tasksHandled<submittedTasks;tasksHandled++){
    try {
        System.out.println("trying to take from Completion service");
        Future<CalcResult> result = taskCompletionService.take();
        System.out.println("result for a task availble in queue.Trying to get()"  );
        // above call blocks till atleast one task is completed and results availble for it
        // but we dont have to worry which one

        // process the result here by doing result.get()
        CalcResult l = result.get();
        System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

    } catch (InterruptedException e) {
        // Something went wrong with a task submitted
        System.out.println("Error Interrupted exception");
        e.printStackTrace();
    } catch (ExecutionException e) {
        // Something went wrong with the result
        e.printStackTrace();
        System.out.println("Error get() threw exception");
    }
}
```

#### 2.2 优雅的任务执行

任务的生命周期不仅包括任务的创建与执行，更包含任务的中断与结束。而针对后者的优雅处理才能体现一个程序员水平，才能让服务更加健壮。

**任务取消**

通常，任务的取消有两种方式：
* 取消标志位
* 中断 （通常针对可响应中断的阻塞）

**任务优雅取消**

通常，我们用线程池的方式来管理线程，ExecutorService提供了优雅的线程取消与线程池关闭的接口与策略。

如通过获取的Future.cancel 来取消任务的执行。
通过 shutdown(等待当前存在的任务执行完成) 和 shutdownNow（不等待，返回未执行完毕的任务）的方式优雅关闭线程池。

**JVM关闭**

当JVM关闭时（通过调用System.exit, 或者Linux中的SIGNAL, 注意 kill -9是不会发送SIGNAL的），可以通过注册JVM钩子来补货关闭信号，并在关闭前执行相应的操作。如：

```java
Thread shutdownThread = ...
Runtime.getRuntime().addShutdownHook(shutdownThread);
```

还需要注意的一点是，Daemon Thread 是不会阻碍JVM关闭的，当JVM停止时，并不会执行Daemon Thread的 finally方法，不会是释放栈。

## 任务执行框架

#### ExecutorService

ExecutorService是最常用的任务执行框架，但是，在使用它进行任务执行时，有很多点需要关注。

**任务隔离**

隔离是代码编写中一种重要的模式，而任务按照执行耗时、资源竞争等作为分组条件，进行线程池划分是代码设计中需要慎重考虑与设计的，关于这点，可以参考Neflix的'Hystrix'框架。

**线程池参数配置**

线程数、任务队列和拒绝策略通常是ExecutorService最关注的三点。

（1）线程数。

线程数关系到系统资源的竞争（过多）与服务吞吐量（过少）。系统硬件资源（CPU个数等）和任务属性（资源竞争）是线程数设置的两个重要的参考指标。通常，如果线程数配置的如果不是过于不合理，是感知不到过大区别的，但是一个程序员代码水平的体现通常也是在这些细节上。
线程数的配置参考：线程个数 = CPU个数 x 预估的CPU利用率 x （1 + 线程等待时间/计算时间）


（2） 任务队列。
任务队列有三种可供选择：无界队列，有界队列，同步队列。
通常来讲，使用ArrayBlockingQueue或者定长大小的LinkedBlockingQueue是更好的选择，可以最大限度的避免当服务能力有限或者请求突增情况下的资源耗尽。

在特定情景下，如对任务执行优先级有限制，使用SynchronousQueue或者PriorityBlockingQueue是更好的选择。

（3）拒绝策略。

当队列已满或者在线程池关闭后提交任务都会触发拒绝策略的执行。默认的实现有Abort,Discard等，也可以自己实现策略接口实现自己的局将策略，如日志，异常上报等。

当然也可以通过包装 ExcutorService 为 BoundedExcutorSerivce的方式， 在任务提交前先使用Semaphore或者Guava的RateLimiter获取执行许可的方式来限制任务提交，来最终达到任务拒绝的目的。
