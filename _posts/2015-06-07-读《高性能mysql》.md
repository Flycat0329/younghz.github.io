--- 
layout: post 
title: "读《高性能mysql》" 
tagline: "mysql 优化" 
description: "" 
category: book 
tags: [book] 
--- 
{% include JB/setup %}

查看表状态：
show table status like “%order_base”    
group_concat()，将查的结果以逗号分隔展示：
select group_concat(id) from table_name;
 

## 优化数据类型
1. 更小的通常更好（占用的存储空间上）。
2. 简单就好（使用内置类型存储时间和日期，使用整型而不是字符串存储IP）。
3. 尽量避免NULL（不会带来很大的性能提升，NULL字段会影响索引、数值比较和存储）

## mysql schema 设计陷阱
1. 太多的列（数据存储端和服务端的数据传输）

## b-tree索引走索引和不走索引的几点

#### 走索引

* 索引中所有列的匹配
* 最左前缀匹配（复合索引）
* 索引列的范围匹配
* 精确匹配某一列并范围匹配另外一列

> 另外由于b-tree的有序性，所以如果查询条件走索引，那么也顺便满足了order by的需求。group by 类似。 

#### 不走索引

* 不满足最左前缀原则（复合索引），需要严格从左到右，且中间不能跳过（若跳过，智能使用前面的索引）。
* 复合索引出现范围查询和模糊查询后就不在走索引。

## 高性能索引策略
* 单独的列，不可以是函数或有操作。
* 复合索引。    

> 当where条件中有多个and条件时，可能更多是需要复合索引而不是单列索引。
> 使用or进行条件查询时，如果没有优化为联合索引，那么结果是耗费内存和cpu的。

* 合适的索列顺序（指的是复合索引的索引顺序的确定，但是在建立索引时应该选择区分度高的字段作为索引。）    
> 将选择性最高的列放在前面（选择性高就意味着区分度低，可用select count(field_name) 来查一下，最好还是根据整体情况来定，而不是某个特定的值。）

* 覆盖索引使用（没有where情况下使用的索引，只支持b-tree索引，因为这种结够是存储数据的。）    
> 定义：如果在索引中已经包含了所有要查询的字段的值，这种情况就叫做`覆盖索引`。这样就不需要在去origin 的表中拿数据。
> 对于count（）操作，覆盖索引能提高性能100倍。

* 索引与Order by     
> explain时若type为index，那么代表使用了索引扫描做排序，否则为通过排序操作做的排序。

* 重复和冗余索引    
> 重复索引就不用说了，如主键上又建了个index。    
> 冗余索引一般是由于复合索引和唯一索引存在冗余，如索引（a,b）和a就是冗余的，但和(b,a)与 b索引都不是冗余的。

***
5.4的案例很好，主要可以总结为下面几点：

* 区分度低的字段是否要建立索引并且在复合索引中的位置。
* 用IN()来解决最左前缀匹配的问题（包括中间不能跳过索引的问题和范围查询导致后面索引失效的问题。）
* 不要滥用IN()解决这类问题，会给优化器造成压力，cpu load高。

***

## 查询性能优化
###是否返回了不需要的数据
### 是否存在额外扫描的记录

* 相应时间。
* 扫描的行数与返回的行数。（10：1之内）    
> 优化此项：    
> > * 使用索引。
> > * 使用**汇总表**。
> > * 重写查询。

## 重构查询的方式
* 使用一个查询还是多个小查询    
> 参考点：
> > * 在MySQL内部，扫面表的速度要比给客户端返回数据的速度要快的多。其他条件相同时优先一个而不是多个小查询。

* 切分查询    
> 讲一个大查询拆分成多个**功能一样**的小查询。比如是从数据库删除数据，每次delete一万条是比较优的做法，否则会锁住数据，耗尽系统资源并阻塞小查询。

* 分解关联查询    
> 是指拆分join型查询，主要考虑一下几个方面：缓存使用、重复数据查询、减少锁的竞争，另外在应用层做数据关联灵活度更高。

* in子查询新能在大部分情况下不能保证，一般情况下更建议将其写成join查询，也可以改为exits查询。

## 优化特定类型的查询
* order by 和group by只涉及到一个表中的字段并且有索引。
* 用**关联查询**优化子查询。
* 优化limit。    
> limit性能影响根本原因在于offset，可以拿掉Offset,通过select * from table_name where id > offset limit limit_num查询
